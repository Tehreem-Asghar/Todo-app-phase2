# Data Model: Todo App

**Feature**: Phase II Full-Stack Todo Web Application
**Date**: 2025-12-31
**Status**: Final

## Entity Relationship Diagram

```
┌─────────────────────────────┐
│     users (Better Auth)     │
│─────────────────────────────│
│ id: UUID (PK)              │
│ email: VARCHAR UNIQUE       │
│ password: VARCHAR (hashed)  │
│ created_at: TIMESTAMP       │
│ updated_at: TIMESTAMP       │
└─────────────┬───────────────┘
              │
              │ 1:N
              │
┌─────────────▼───────────────┐
│   users_sync (FastAPI)      │
│─────────────────────────────│
│ id: UUID (PK, FK)          │
│ email: VARCHAR              │
│ created_at: TIMESTAMP       │
└─────────────┬───────────────┘
              │
              │ 1:N
              │
┌─────────────▼───────────────┐
│     todos (FastAPI)         │
│─────────────────────────────│
│ id: UUID (PK)              │
│ user_id: UUID (FK)         │
│ title: VARCHAR(500)         │
│ description: TEXT (nullable)│
│ completed: BOOLEAN          │
│ created_at: TIMESTAMP       │
│ updated_at: TIMESTAMP       │
└─────────────────────────────┘
```

## Entities

### 1. User (Better Auth Managed)

**Table**: `users`
**Owner**: Better Auth library
**Purpose**: Stores user authentication credentials and account information

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Unique user identifier (generated by Better Auth) |
| `email` | VARCHAR(255) | UNIQUE, NOT NULL | User's email address (used for login) |
| `password` | VARCHAR(255) | NOT NULL | Bcrypt-hashed password (managed by Better Auth) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Account creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last account update timestamp |

**Notes**:
- Better Auth manages this table via its own migrations
- FastAPI does NOT modify this table directly
- Password hashing uses bcrypt with 12+ rounds (Better Auth default)
- Email validation enforced by Better Auth during registration

**Relationships**:
- **Has many** `users_sync` (1:1 relationship after sync)
- **Has many** `todos` (via `users_sync` foreign key)

---

### 2. UserSync (FastAPI Managed)

**Table**: `users_sync`
**Owner**: FastAPI application
**Purpose**: Minimal user reference for foreign key relationships with todos

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY, FOREIGN KEY → users.id | User identifier (matches Better Auth user ID) |
| `email` | VARCHAR(255) | NOT NULL | User's email (synced from JWT payload) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Sync timestamp (when user first synced to FastAPI) |

**Notes**:
- Created via `POST /api/users/sync` after Better Auth registration
- Does NOT store passwords or authentication data
- Upsert behavior: `ON CONFLICT (id) DO NOTHING` (idempotent)
- Foreign key constraint ensures user exists in Better Auth table

**Relationships**:
- **Belongs to** `users` (1:1 via `id` foreign key)
- **Has many** `todos` (1:N relationship)

**Indexes**:
- Primary key index on `id` (automatic)

---

### 3. Todo (FastAPI Managed)

**Table**: `todos`
**Owner**: FastAPI application
**Purpose**: Stores user's todo items with completion status

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | UUID | PRIMARY KEY | Unique todo identifier (prevents enumeration attacks) |
| `user_id` | UUID | FOREIGN KEY → users_sync.id, NOT NULL | Owner of the todo item (user isolation) |
| `title` | VARCHAR(500) | NOT NULL | Todo item title (1-500 characters) |
| `description` | TEXT | NULLABLE | Optional detailed description (no length limit) |
| `completed` | BOOLEAN | NOT NULL, DEFAULT FALSE | Completion status (false = incomplete, true = completed) |
| `created_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Todo creation timestamp |
| `updated_at` | TIMESTAMP | NOT NULL, DEFAULT NOW() | Last modification timestamp (auto-updated on changes) |

**Notes**:
- UUID prevents ID enumeration attacks (spec requirement)
- All queries MUST filter by `user_id` from JWT (data isolation)
- Title validation: 1-500 characters, cannot be empty/whitespace only
- Description is optional (allows quick task creation)
- `updated_at` automatically updated via database trigger or application logic

**Relationships**:
- **Belongs to** `users_sync` (N:1 via `user_id` foreign key)

**Indexes**:
- Primary key index on `id` (automatic)
- Index on `user_id` (critical for query performance on `WHERE user_id = ...`)
- Composite index on `(user_id, created_at DESC)` (optimizes paginated queries)

**Validation Rules** (enforced by Pydantic):
- `title`: Required, 1-500 chars, must not be empty/whitespace
- `description`: Optional, max 2000 chars (reasonable limit)
- `completed`: Boolean (defaults to `false`)

---

## Database Schema (SQL DDL)

### Better Auth Tables

```sql
-- Managed by Better Auth migrations
-- DO NOT modify directly in FastAPI migrations

CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

### FastAPI Tables

```sql
-- FastAPI migrations (Alembic)

CREATE TABLE users_sync (
    id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    email VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE todos (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users_sync(id) ON DELETE CASCADE,
    title VARCHAR(500) NOT NULL,
    description TEXT,
    completed BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Performance indexes
CREATE INDEX idx_todos_user_id ON todos(user_id);
CREATE INDEX idx_todos_user_created ON todos(user_id, created_at DESC);
```

### Auto-Update Trigger for `updated_at`

```sql
-- Trigger to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_todos_updated_at
    BEFORE UPDATE ON todos
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
```

---

## SQLModel Definitions (Python)

### User Sync Model

```python
# backend/src/models/user.py
from sqlmodel import SQLModel, Field
from datetime import datetime
from uuid import UUID

class UserSync(SQLModel, table=True):
    __tablename__ = "users_sync"

    id: UUID = Field(primary_key=True, foreign_key="users.id")
    email: str = Field(max_length=255, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
```

### Todo Model

```python
# backend/src/models/todo.py
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from uuid import UUID, uuid4
from typing import Optional

class Todo(SQLModel, table=True):
    __tablename__ = "todos"

    id: UUID = Field(default_factory=uuid4, primary_key=True)
    user_id: UUID = Field(foreign_key="users_sync.id", nullable=False, index=True)
    title: str = Field(max_length=500, nullable=False)
    description: Optional[str] = Field(default=None)
    completed: bool = Field(default=False, nullable=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

    # Relationship (optional, for ORM convenience)
    user: Optional["UserSync"] = Relationship(back_populates="todos")
```

---

## Pydantic Schemas (Request/Response DTOs)

### Todo Schemas

```python
# backend/src/schemas/todo.py
from pydantic import BaseModel, Field, validator
from datetime import datetime
from uuid import UUID
from typing import Optional

class TodoCreate(BaseModel):
    """Request body for creating a new todo"""
    title: str = Field(..., min_length=1, max_length=500)
    description: Optional[str] = Field(None, max_length=2000)

    @validator('title')
    def title_not_empty(cls, v: str) -> str:
        if not v.strip():
            raise ValueError('Title cannot be empty or whitespace')
        return v.strip()

class TodoUpdate(BaseModel):
    """Request body for updating a todo"""
    title: Optional[str] = Field(None, min_length=1, max_length=500)
    description: Optional[str] = Field(None, max_length=2000)
    completed: Optional[bool] = None

    @validator('title')
    def title_not_empty(cls, v: Optional[str]) -> Optional[str]:
        if v is not None and not v.strip():
            raise ValueError('Title cannot be empty or whitespace')
        return v.strip() if v else None

class TodoResponse(BaseModel):
    """Response body for todo operations"""
    id: UUID
    user_id: UUID
    title: str
    description: Optional[str]
    completed: bool
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # Enable ORM mode for SQLModel compatibility
```

### User Schemas

```python
# backend/src/schemas/user.py
from pydantic import BaseModel
from datetime import datetime
from uuid import UUID

class UserSyncResponse(BaseModel):
    """Response body for user sync operation"""
    id: UUID
    email: str
    created_at: datetime

    class Config:
        from_attributes = True
```

---

## Data Isolation Strategy

**Critical Security Requirement**: All todo queries MUST filter by `user_id` extracted from JWT token.

### Example Query Patterns

**Correct (Isolated)**:
```python
# Get user's todos
todos = session.exec(
    select(Todo)
    .where(Todo.user_id == current_user.id)
    .order_by(Todo.created_at.desc())
).all()

# Get specific todo (returns None if not owned by user)
todo = session.exec(
    select(Todo)
    .where(Todo.user_id == current_user.id)
    .where(Todo.id == todo_id)
).first()
```

**Incorrect (Vulnerable)**:
```python
# ❌ SECURITY VIOLATION: No user_id filter
todo = session.get(Todo, todo_id)  # Exposes other users' todos!
```

### Error Handling

- **Todo not found OR not owned by user**: Return `404 Not Found` (spec FR-015)
- **Unauthenticated request**: Return `401 Unauthorized`
- **Invalid UUID format**: Return `400 Bad Request`

---

## Migration Strategy

### Initial Migration (Alembic)

```bash
# Generate migration
alembic revision --autogenerate -m "Initial schema: users_sync and todos"

# Apply migration
alembic upgrade head
```

### Migration Dependencies

1. Better Auth migrations MUST run first (creates `users` table)
2. FastAPI migrations create `users_sync` and `todos` (depend on `users` table existing)

### Rollback Strategy

```bash
# Rollback last migration
alembic downgrade -1

# Rollback to specific revision
alembic downgrade <revision_id>
```

---

## Testing Data Fixtures

### Sample Test Data

```python
# tests/fixtures/test_data.py
import uuid

TEST_USER_1 = {
    "id": uuid.UUID("12345678-1234-5678-1234-567812345678"),
    "email": "alice@example.com",
}

TEST_USER_2 = {
    "id": uuid.UUID("87654321-4321-8765-4321-876543218765"),
    "email": "bob@example.com",
}

TEST_TODO_1 = {
    "id": uuid.UUID("aaaaaaaa-1111-2222-3333-444444444444"),
    "user_id": TEST_USER_1["id"],
    "title": "Buy groceries",
    "description": "Milk, eggs, bread",
    "completed": False,
}

TEST_TODO_2 = {
    "id": uuid.UUID("bbbbbbbb-5555-6666-7777-888888888888"),
    "user_id": TEST_USER_2["id"],
    "title": "Finish report",
    "description": None,
    "completed": True,
}
```

---

## Acceptance Criteria Validation

- [x] User entity managed by Better Auth with bcrypt password hashing
- [x] UserSync entity for FastAPI foreign key relationships
- [x] Todo entity with UUID identifiers (prevents enumeration)
- [x] All queries filter by `user_id` (data isolation enforced)
- [x] Timestamps (`created_at`, `updated_at`) on all entities
- [x] Foreign key constraints ensure referential integrity
- [x] Indexes on `user_id` for query performance
- [x] Pydantic validation for title length (1-500 chars) and non-empty
- [x] 404 response for cross-user access attempts (not 403)
- [x] Database schema supports all functional requirements (FR-001 to FR-031)
